#!/usr/bin/env python

import argparse
import collections
import sqlite3
import re

import pandas as pd

import pygit2

EMPTY_TREE_SHA = '4b825dc642cb6eb9a060e54bf8d69288fbee4904'

def create_database(filename):
    conn = sqlite3.connect(filename)
    conn.execute("""
        CREATE TABLE IF NOT EXISTS changes (
            id INTEGER PRIMARY KEY,
            repo TEXT NOT NULL,
            patchset INTEGER NOT NULL,
            patch INTEGER NOT NULL,
            sha TEXT NOT NULL,
            date INTEGER NOT NULL,
            author_id INTEGER NOT NULL,
            status TEXT,
            type TEXT NOT NULL,
            label TEXT,
            value INTEGER,
            bot_like INTEGER NOT NULL
         )""")

    return conn

def save_change(commit, conn, patchset, patch, repo_name):
    t = 'unknown'
    bot_like = 1 if commit.bot_like else 0
    if isinstance(commit, Patch):
        t = 'patch'
        l = None
        v = None
    if isinstance(commit, Comment):
        t = 'comment'
        l = None
        v = None
    if isinstance(commit, Label):
        t = 'label'
        l = commit.type
        v = commit.vote
    if isinstance(commit, Reviewer):
        t = 'reviewer'
        l = None
        v = None
    conn.execute("""
        INSERT INTO changes (repo, patchset, patch, sha, date, author_id, type, status, label, value, bot_like)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
        (repo_name, patchset, patch, commit.sha, commit.date, commit.author, t, commit.status, l, v, bot_like))

def do_save(commits, conn, repo_name):
    for commit in commits:
        if isinstance(commit, Patch):
            last_patchset = commit.ps.patchset
            last_patch = commit.patch
        save_change(commit, conn, last_patchset, last_patch, repo_name)

def get_commit_author_id(commit):
    if commit.author.email == 'gerrit@wikimedia.org':
        return 0
    return int(commit.author.email.split('@')[0])


class MetaCommit(object):
    def __init__(self, commit):
        self.commit = commit
        self.author = get_commit_author_id(commit)
        self.date = commit.author.time
        self.sha = commit.hex
        self.trailer_re = re.compile(r'(?P<key>[a-zA-Z-_]+)+:\s?(?P<value>.*)')
        self._comments = None
        self._trailers = None

    @property
    def trailers(self):
        """
        TODO: fix in pygit2
        """
        if self._trailers is None:
            self._trailers = {}
            rev_message = self.commit.message.splitlines()[::-1]
            for line in rev_message:
                if not line.strip():
                    break
                if ':' not in line:
                    continue
                m = self.trailer_re.match(line)
                if m:
                    if self._trailers.get(m['key'], None) is None:
                        self._trailers[m['key']] = m['value'].strip()
                    else:
                        self._trailers[m['key']] += '\n' + m['value'].strip()
        return self._trailers

    @property
    def is_reviewer(self):
        reviewer = self.trailers.get('Reviewer', None)
        return reviewer is not None

    @property
    def is_label(self):
        has_label = self.trailers.get('Label', None) is not None
        if not has_label:
            return False
        for _, vote in self.get_votes():
            if vote != 0:
                return True

    @property
    def is_patch(self):
        is_ps = self.trailers.get('Patch-set', None) is not None
        return is_ps and \
            self.has_new_patch_comments()

    @property
    def is_comment(self):
        """
        Inline comments, but not a new patchset
        Or patch comments
        """
        has_real_comments = len(self._patch_comments()) > 0
        return self.has_inline_comments() or has_real_comments

    @property
    def is_botlike(self):
        tag = self.trailers.get('Tag', None)
        if tag is None:
            return False
        if tag.startswith('autogenerated') and \
              not tag.endswith('abandon'):
            return True

    def make_reviewers(self, ps):
        for reviewer_id in self.get_reviewer_ids():
            if reviewer_id in ps.known_reviewers:
                continue
            yield Reviewer(self.commit, self, ps, reviewer_id)

    def get_votes(self):
        labels = self.trailers['Label'].splitlines()
        label_objs = []
        for label in labels:
            if label.startswith('-'):
                label = label[1:].split(' ')[0]
                vote = 0
            else:
                label, vote = label.split('=')
                # Got to handle: 
                # - Label: Code-Review=+2
                # - Label: Code-Review=+2 Gerrit User <gerrit@wikimedia>
                vote = int(vote.split(' ')[0])
            yield label, vote

    def make_labels(self, ps):
        for label, vote in self.get_votes():
            if vote == 0:
                continue
            if label == 'Code-Review':
                yield CodeReview(self.commit, self, ps, vote)
            elif label == 'Verified':
                yield Verified(self.commit, self, ps, vote)
            elif label == 'SUBM':
                yield Submit(self.commit, self, ps, vote)
            else:
                import pdb; pdb.set_trace()
                raise('Unknown label')

    def has_inline_comments(self):
        return (
            self.has_updated_tree() and
            not self.has_new_patch_comments()
        )

    def get_reviewer_ids(self):
        reviewer_ids = []
        for reviewer in self.trailers['Reviewer'].splitlines():
            reviewer_ids.append(int(reviewer.split('<')[1].split('@')[0]))
        return reviewer_ids

    def has_new_patch_comments(self):
        return len(self._newpatchpatchset_comments()) > 0

    def has_updated_tree(self):
        parent_tree = EMPTY_TREE_SHA

        if self.commit.parents:
            parent_tree = self.commit.parents[0].tree.id

        return parent_tree != self.commit.tree.id

    def get_comments(self):
        if self._comments is None:
            self._comments = [
                l for l in self.commit.message.splitlines()
                if l.strip() and
                   l.split(':')[0] not in self.trailers
            ]
        return self._comments

    def _newpatch_line(self, line):
        l = line.lower()
        return (l.startswith('create change') or
                l.startswith('uploaded patch set') or
                l.startswith('create patch set'))

    def _status_line(self, line):
        return line.lower().startswith('update patch set')

    def _newpatchpatchset_comments(self):
        return [
            l for l in self.get_comments()
            if self._newpatch_line(l)
        ]

    def _patch_comments(self):
        """
        Real actual comments only
        """
        return [
            l for l in self.get_comments()
            if (
                not self._newpatch_line(l)
                and not self._status_line(l)
            )
        ]


class Reviewer(MetaCommit):
    def __init__(self, commit, mc, ps, reviewer_id):
        super(Reviewer, self).__init__(commit)
        self.update = True
        self.reviewer = reviewer_id
        self.status = mc.trailers.get('Status')
        self.label = mc.trailers.get('Label')
        self.message = mc.get_comments()
        self.mc = mc
        self.ps = ps
        self.bot_like = mc.is_botlike

    def __repr__(self):
        return '<Reviewer %s> addedby %s (%s)' % (
            self.reviewer, self.author, self.status)


class Comment(MetaCommit):
    def __init__(self, commit, mc, ps):
        super(Comment, self).__init__(commit)
        self.update = True
        self.reviewer = self.author
        self.status = mc.trailers.get('Status')
        self.label = mc.trailers.get('Label')
        self.message = mc.get_comments()
        self.mc = mc
        self.ps = ps
        self.bot_like = mc.is_botlike

    def __repr__(self):
        thing = '<Comment %s>' % self.reviewer
        thing += ' addedby %s' % self.author
        thing += ' (%s)' % self.status
        if self.bot_like:
            thing += ' (bot)'
        return thing

class Label(MetaCommit):
    def __init__(self, commit, mc, ps):
        super(Label, self).__init__(commit)
        self.update = True
        self.reviewer = self.author
        self.status = mc.trailers.get('Status')
        self.label = mc.trailers['Label']
        self.message = mc.get_comments()
        self.mc = mc
        self.ps = ps
        self.bot_like = mc.is_botlike
        self.vote = 0
        self.type = '?'

class CodeReview(Label):
    def __init__(self, commit, mc, ps, vote):
        super(CodeReview, self).__init__(commit, mc, ps)
        self.vote = vote
        self.type = 'c'

    def __repr__(self):
        return '<CodeReview %s> by %s (%s)' % (
            self.vote, self.author, self.status)

class Verified(Label):
    def __init__(self, commit, mc, ps, vote):
        super(Verified, self).__init__(commit, mc, ps)
        self.vote = vote
        self.type = 'v'

    def __repr__(self):
        return '<Verified %s> by %s (%s)' % (
            self.vote, self.author, self.status)

class Submit(Label):
    def __init__(self, commit, mc, ps, vote):
        super(Submit, self).__init__(commit, mc, ps)
        self.vote = vote
        self.type = 's'

    def __repr__(self):
        return '<Submit %s> by %s (%s)' % (
            self.vote, self.author, self.status)

class Patch(MetaCommit):
    def __init__(self, commit, mc, ps):
        super(Patch, self).__init__(commit)
        self.patch = int(mc.trailers['Patch-set'])
        self.status = mc.trailers.get('Status')
        self.change_id = mc.trailers.get('Change-id')
        self.target_branch = mc.trailers.get('Branch')
        self.owner_id = self.author
        self.subject = mc.trailers.get('Subject')
        self.mc = mc
        self.ps = ps
        self.bot_like = False

    def __repr__(self):
        return '<Patch %s> by %s (%s)' % (
            self.patch, self.author, self.status
        )


class Patchset(object):
    def __init__(self, repo, ref):
        self.repo = repo
        self.ref = ref
        self.sha = ref.target.hex
        self.patchset = int(ref.name.split('/')[3])
        self.patchset_ref = ref.name
        self.known_reviewers = set()
        self.commits = []
        self.patches = []

    def known_reviewer(self, reviewers):
        for reviewer in reviewers:
            if reviewer.reviewer in self.known_reviewers:
                return True
            self.known_reviewers.add(reviewer.reviewer)
        return False

    def walk(self, known):
        """
        Each commit is either:
        - A patch
        - A comment
        - Adds several labels
        - Adds several reviewers
        """
        for commit in self.repo.walk(self.ref.target, pygit2.GIT_SORT_REVERSE):
            # 0 will only be here if it's the first time we've run this
            if 0 not in known and commit.hex not in known:
                continue
            mc = MetaCommit(commit)
            # print('    - Processing commit %s' % mc.sha)
            if mc.is_patch:
                patch = Patch(commit, mc, self)
                self.patches.append(patch)
                self.commits.append(patch)

            if mc.is_reviewer:
                for reviewer in mc.make_reviewers(self):
                    self.commits.append(reviewer)
                    self.known_reviewers.add(reviewer.reviewer)

            # These are all updates.
            # - Patches are important, otherwise they're updates to an existing patch
            # - Labels > Comments > Reviewers
            if mc.is_patch:
                pass
            elif mc.is_label:
                for label in mc.make_labels(self):
                    self.commits.append(label)
                    self.known_reviewers.add(label.author)
            elif mc.is_comment:
                comment = Comment(commit, mc, self)
                self.commits.append(comment)
                self.known_reviewers.add(comment.author)

        yield self.commits

def parse_args():
    ap = argparse.ArgumentParser()
    ap.add_argument('--name', help='Name of the repo')
    ap.add_argument('--repo', help='Path to the repo')
    ap.add_argument('--new-shas', help='csv of new shas')
    ap.add_argument('--safe-path', help='safe path name for db')
    ap.add_argument('--out-dir', help='where to put the output')
    return ap.parse_args()

def main():
    args = parse_args()
    conn = create_database(f"{args.out_dir}/{args.safe_path}.db")
    conn.execute("BEGIN TRANSACTION")
    repo = pygit2.Repository(args.repo)
    df = pd.read_csv(args.new_shas)
    # Get known shas from the csv, grouped by individual ref names
    print('Processing %s' % args.name)
    known_shas = df.groupby('refname')['commit'].apply(list).to_dict()
    for ref, known in known_shas.items():
        print('Processing %s - %s' % (args.name, ref))
        count = 0
        for commit in Patchset(repo, repo.lookup_reference(ref)).walk(set(known)):
            if isinstance(commit, list):
                for c in commit:
                    print('    - %s' % c)
            else:
                print('    - %s' % commit)
            do_save(commit, conn, args.name)
            if count % 100 == 0:
                print('Committing changes')
                conn.commit()
                conn.execute("BEGIN TRANSACTION")
            del commit  # Neeed to free memory...
    conn.commit()
    conn.close()

if __name__ == '__main__':
    main()
